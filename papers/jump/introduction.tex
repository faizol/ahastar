\section{Introduction}
The most popular and successful pathfinding algorithms, such as A*, Bellman-Ford
and Dijkstra's Algorithm have all been developed in the context of general
purpose problem graphs.  Finding a shortest path in such domains usually
requires only that the start and goal locations belong to the same connected
component, that the graph contains no negative weight edges and, in the case of
A*, that an admissible heuristic is available.  It is often the case however
that these same algorithms are usually deployed on problem domains which are
more constrained: undirected positively weighted graphs where each node
corresponds to a location on a 2D Euclidean plane.
%The latter restriction is commonly exploited by researchers in order to develop
%more efficient search algorithms; for example in the context of the TSP. 
%By making use of the triangle inequality, researchers are able to identify 
%pruning opportunities which ... <something>
Perhaps the most common example of such a domain is the ubiquitous grid map.

Frequently the object of academic study \cite{yap02,botea04,bjornsson06} and
widely employed in application areas such as robotics \cite{choset05} and video
games \cite{sturtevant07}, grid maps are highly regular domains which
typically feature a high degree of path symmetry \cite{harabor10,pochter10}.
Symmetry in this case manifests itself as paths (or path segments) which share
the same start and end point, have the same length and are otherwise identical
save for the order in which moves occur.
%; Figure \ref{fig:symmetry} shows a typical example.  
Unless it is handled properly, symmetry can force search algorithms 
to evaluate many equivalent states and prevents real progress toward
the goal.

In this paper we deal with path symmetries in uniform-cost grid maps by 
developing a macro operator that selectively expands only certain nodes from the grid, 
which we call
\emph{jump points}. Moving from one jump point to the next involves travelling
in a fixed direction while repeatedly applying a set of simple neighbour pruning
rules until either a dead-end or a jump point is reached.  Because we do not
expand any intermediate nodes between jump points our strategy can have a
dramatic positive effect on search performance.  Furthermore, computed solutions
are guaranteed to be optimal.  Unlike other methods for speeding up
optimal search, such as the Dead-end Heuristic \cite{bjornsson06}, Empty
Rectangular Rooms \cite{harabor10} and Swamp-based pathfinding \cite{pochter10},
our method is applied online, requires no pre-processing and has no associated
memory overheads.  As we will discuss later, jump points are also largely
orthogonal to many existing speedup techniques that are also applicable to grid
maps.

We make the following contributions: (i) a detailed description of the jump
points algorithm; (ii) a theoretical result which shows that searching with jump
points preserves optimality;  (iii) an empirical analysis comparing our method
with two state-of-the-art search space reduction algorithms.  We run experiments
on synthetic and real-world benchmarks, including two sets of maps taken from
the popular video games \emph{Dragon Age: Origins} and \emph{Baldur's Gate II:
Shadows of Amn}.  Our results indicate that searching with jump points improves
the search time performance of standard A* by more than on order of magnitude.
We also report significant improvement over Swamps \cite{pochter10}, a recent
optimality preserving pruning technique, and performance competitive with HPA*
\cite{botea04}, a well known sub-optimal pathfinding algorithm.
