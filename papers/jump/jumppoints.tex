\section{Jump Points}
In the previous section we developed rules for pruning neighbours during 
individual node expansions. We now extend this idea in order to define a 
macro-step operator which speeds up optimal search by identifying dead ends in the 
search space much sooner than would otherwise be the case.
The basic idea can be outlined as such:  following a pruning operation on some
arbitrary node $x$, we defer the immediate generation of all remaining neighbours 
and instead, continue travelling in the same direction until we reach an obstacle 
or identify an eventual successor which satisfies certain properties and which 
we term a \emph{jump node}.
If we find such a jump node, we generate it as a successor of $x$; if we do not 
find a jump node, we generate nothing.

\subsection{Straight Jump Nodes}


\subsection{Diagonal Jump Nodes}



\subsection{Optimality}
Sketch: show that each pruning rule discards only neighbours
which cannot belong to the optimal path for the problem at hand.
Then, by induction, demonstrate that jump points have the same 
property. 

Complications:
 - jump points when passing the row or column associated with the goal
 - no jump points at the top of a row/column ending in an obstacle.

